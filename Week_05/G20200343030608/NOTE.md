解题思路：

最小路径和：
状态定义：

设 dp为大小m×n 矩阵，其中 dp[i][j]的值代表直到走到 (i,j)的最小路径和。
转移方程：

题目要求，只能向右或向下走，换句话说，当前单元格 (i,j)只能从左方单元格 (i-1,j) 或上方单元格(i,j−1) 走到，因此只需要考虑矩阵左边界和上边界。

走到当前单元格 (i,j)的最小路径和 = “从左方单元格(i−1,j)与从上方单元格(i,j-1)走来的 两个最小路径和中较小的 ” +当前单元格值 grid[i][j]。具体分为以下4种情况：
当左边和上边都不是矩阵边界时： 即当i 不等于 0， j不等于0时，
    dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j]dp[i][j]；
当只有左边是矩阵边界时： 只能从上面来，即当i = 0, j 不等于0，时， 
    dp[i][j] = dp[i][j - 1] + grid[i][j]dp[i][j]=dp[i][j−1]+grid[i][j] ；
当只有上边是矩阵边界时： 只能从左面来，即当i不等于0, j = 0时， 
    dp[i][j] = dp[i - 1][j] + grid[i][j]dp[i][j]=dp[i−1][j]+grid[i][j] ；
当左边和上边都是矩阵边界时： 即当i = 0, j = 0时，其实就是起点， 
    dp[i][j] = grid[i][j]dp[i][j]=grid[i][j]；
初始状态：

dp初始化即可，不需要修改初始 0 值。
返回值：

返回 dp矩阵右下角值，即走到终点的最小路径和。
其实我们完全不需要建立 dp 矩阵浪费额外空间，直接遍历 grid[i][j] 修改即可。这是因为：grid[i][j] = min(grid[i - 1][j], grid[i][j - 1]) + grid[i][j] ；原 grid 矩阵元素中被覆盖为 dp 元素后（都处于当前遍历点的左上方），不会再被使用到。


动态规划：
这道题和爬楼梯的那道题的思路很像，都是最后一种状态由前两种状态转化而来。

1.我们知道最后一个字母有可能是由一个数字串或两个数字串转化而来，例如'12312'这个数字串，转化成字母串最后一位可以是'2'转成B，也可能是'12'转成L

2.设数字串S的前i个数字解密成字母串有dp[i]种方式：那么就有dp[i] = dp[i-1] + dp[i-2]

dp[i-1]表示最后一个数字解密成一个字母
dp[i-2]表示最后两个数字解密成一个字母
3.由于这里存在很多特殊情况：

例如dp[i-2]表示最后两个数字解密成一个字母的情况必须要至少有两个数字
例如最后两个字母大于26，像55、01等是不存在dp[i-2]这种情况的
所以，像下面的拆开写状态转移方程，分别判断是很好的思路，见代码。
注：代码是看别人的思路自己转写的，膜拜大佬。
